// MovementController.jsx
import React, { useRef, useEffect } from "react";
import { useFrame } from "@react-three/fiber";
import { useSphere } from "@react-three/cannon";
import * as THREE from 'three';

const MovementController = ({ cameraRef }) => {
  const velocity = useRef({ x: 0, z: 0 });
  const direction = useRef({ yaw: 0, pitch: 0 });
  const speed = 3; // Increase speed to be noticeable in physics calculations
  const rotationSpeed = 0.002;

  // Define a sphere collider for the player with @react-three/cannon
  const [ref, api] = useSphere(() => ({
    mass: 1,
    position: [0, 1, 5],
    args: 1,
    type: "Dynamic",
  }));

  useEffect(() => {
    const onKeyDown = (e) => {
      if (e.key === "w") velocity.current.z = -speed;
      if (e.key === "s") velocity.current.z = speed;
      if (e.key === "a") velocity.current.x = -speed;
      if (e.key === "d") velocity.current.x = speed;
    };

    const onKeyUp = (e) => {
      if (e.key === "w" || e.key === "s") velocity.current.z = 0;
      if (e.key === "a" || e.key === "d") velocity.current.x = 0;
    };

    const onMouseMove = (e) => {
      direction.current.yaw = e.movementX * rotationSpeed;
      direction.current.pitch = e.movementY * rotationSpeed;
    };

    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("keyup", onKeyUp);
    window.addEventListener("mousemove", onMouseMove);

    return () => {
      window.removeEventListener("keydown", onKeyDown);
      window.removeEventListener("keyup", onKeyUp);
      window.removeEventListener("mousemove", onMouseMove);
    };
  }, []);

  useFrame(() => {
    if (cameraRef.current) {
      // Limit pitch to avoid rolling and keep the camera upright
      const euler = new THREE.Euler(0, 0, 0, 'YXZ');
      euler.setFromQuaternion(cameraRef.current.quaternion);

      // Apply yaw (left-right rotation)
      euler.y -= direction.current.yaw;

      // Apply pitch (up-down rotation), clamped to prevent flipping
      euler.x -= direction.current.pitch;
      euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

      // Set the updated rotation back to the camera
      cameraRef.current.quaternion.setFromEuler(euler);

      // Reset direction after each frame to stop continuous panning
      direction.current.yaw = 0;
      direction.current.pitch = 0;

      // Update camera position based on key presses by applying force
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cameraRef.current.quaternion);
      const rightMovement = new THREE.Vector3(1, 0, 0).applyQuaternion(cameraRef.current.quaternion);

      // Apply force to the sphere (gravity and collision will be handled by cannon)
      const force = new THREE.Vector3();
      force.addScaledVector(forward, velocity.current.z);
      force.addScaledVector(rightMovement, velocity.current.x);

      api.velocity.set(force.x, api.velocity.current[1], force.z);

      // Sync camera position with physics sphere
      const position = ref.current.position;
      cameraRef.current.position.set(position.x, position.y, position.z);
    }
  });

  return (
    <mesh ref={ref}>
      <sphereBufferGeometry args={[1, 32, 32]} />
      <meshStandardMaterial transparent opacity={0} />
    </mesh>
  );
};

export default MovementController;
